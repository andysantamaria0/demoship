import * as core from "@actions/core";
import * as github from "@actions/github";

interface VideoResponse {
  video_id: string;
  status: string;
  share_url: string;
  status_url: string;
}

interface VideoStatus {
  video_id: string;
  status: string;
  share_url: string | null;
  video_url: string | null;
  error: string | null;
}

async function run(): Promise<void> {
  try {
    // Get inputs
    const apiKey = core.getInput("api-key", { required: true });
    const postComment = core.getInput("post-comment") === "true";
    const apiUrl = core.getInput("api-url") || "https://demoship.dev";
    const timeout = parseInt(core.getInput("timeout") || "300", 10);

    // Validate we're in a PR context
    const context = github.context;
    if (context.eventName !== "pull_request") {
      core.setFailed("This action only works on pull_request events");
      return;
    }

    const pr = context.payload.pull_request;
    if (!pr) {
      core.setFailed("Could not find pull request in event payload");
      return;
    }

    // Check if PR was merged
    if (!pr.merged) {
      core.info("PR was not merged, skipping video generation");
      return;
    }

    const prUrl = pr.html_url;
    core.info(`Generating video for PR: ${prUrl}`);

    // Call DemoShip API to create video
    const createResponse = await fetch(`${apiUrl}/api/v1/videos`, {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
        Authorization: `Bearer ${apiKey}`,
      },
      body: JSON.stringify({
        pr_urls: [prUrl],
      }),
    });

    if (!createResponse.ok) {
      const errorData = await createResponse.json().catch(() => ({}));
      throw new Error(
        `Failed to create video: ${errorData.error || createResponse.statusText}`
      );
    }

    const videoData: VideoResponse = await createResponse.json();
    core.info(`Video creation started: ${videoData.video_id}`);
    core.setOutput("video-id", videoData.video_id);

    // Poll for completion
    const startTime = Date.now();
    const pollInterval = 10000; // 10 seconds
    let finalStatus: VideoStatus | null = null;

    while (Date.now() - startTime < timeout * 1000) {
      await sleep(pollInterval);

      const statusResponse = await fetch(
        `${apiUrl}/api/v1/videos/${videoData.video_id}`,
        {
          headers: {
            Authorization: `Bearer ${apiKey}`,
          },
        }
      );

      if (!statusResponse.ok) {
        core.warning(`Failed to check video status: ${statusResponse.statusText}`);
        continue;
      }

      finalStatus = await statusResponse.json();
      core.info(`Video status: ${finalStatus?.status}`);

      if (finalStatus?.status === "complete") {
        core.info("Video generation complete!");
        break;
      }

      if (finalStatus?.status === "failed") {
        throw new Error(`Video generation failed: ${finalStatus.error}`);
      }
    }

    if (!finalStatus || finalStatus.status !== "complete") {
      throw new Error("Video generation timed out");
    }

    // Set outputs
    core.setOutput("share-url", finalStatus.share_url);
    core.setOutput("status", finalStatus.status);

    // Post comment if enabled
    if (postComment && finalStatus.share_url) {
      const token = process.env.GITHUB_TOKEN;
      if (!token) {
        core.warning(
          "GITHUB_TOKEN not available, skipping PR comment. Add 'permissions: pull-requests: write' to your workflow."
        );
      } else {
        const octokit = github.getOctokit(token);

        const comment = `## Demo Video Generated

Your demo video is ready!

[Watch Video](${finalStatus.share_url})

---
*Generated by [DemoShip](https://demoship.dev)*`;

        await octokit.rest.issues.createComment({
          owner: context.repo.owner,
          repo: context.repo.repo,
          issue_number: pr.number,
          body: comment,
        });

        core.info("Posted video link as PR comment");
      }
    }

    core.info(`Video available at: ${finalStatus.share_url}`);
  } catch (error) {
    if (error instanceof Error) {
      core.setFailed(error.message);
    } else {
      core.setFailed("An unexpected error occurred");
    }
  }
}

function sleep(ms: number): Promise<void> {
  return new Promise((resolve) => setTimeout(resolve, ms));
}

run();
